"""
Gemini 3 Flash reasoning engine with Google Search grounding.

Provides 6-pillar institutional investment analysis:
  1. industry_competition
  2. product_sales
  3. fundamentals
  4. reputation_papers
  5. technical_analysis
  6. synthesis

Used by the /api/ai/company-rationale endpoint as the primary reasoning
backend when GEMINI_API_KEY is configured.
"""

import asyncio
import logging
import os
import json
import re
from typing import Dict, List, Any

import google.generativeai as genai
from dotenv import load_dotenv

load_dotenv()

logger = logging.getLogger(__name__)

PILLAR_NAMES = [
    "industry_competition",
    "product_sales",
    "fundamentals",
    "reputation_papers",
    "technical_analysis",
    "synthesis",
]

PILLAR_LABELS = {
    "industry_competition": "Industry & Competition",
    "product_sales": "Product & Sales",
    "fundamentals": "Financial Fundamentals",
    "reputation_papers": "Research & Reputation",
    "technical_analysis": "Technical Analysis",
    "synthesis": "Synthesis",
}

# Standard unknowns required by the compliance layer
STANDARD_UNKNOWNS = [
    {
        "unknown_id": "execution_price",
        "description": "The exact price(s) at which trades were executed",
        "is_standard": True,
    },
    {
        "unknown_id": "investor_reasoning",
        "description": "The investor's actual private reasoning and decision-making process",
        "is_standard": True,
    },
    {
        "unknown_id": "future_intentions",
        "description": "Whether the investor plans to increase, decrease, or maintain this position",
        "is_standard": True,
    },
]

DISCLAIMER = (
    "This analysis is generated by AI based on publicly available information. "
    "It represents hypothetical reasoning, not the investor's actual rationale. "
    "Do not make investment decisions based on this analysis."
)


# ---------------------------------------------------------------------------
# JSON cleaning
# ---------------------------------------------------------------------------

def clean_json_text(text: str) -> str:
    """Extract and repair JSON from LLM output that may have markdown wrappers."""
    start_idx = text.find("{")
    if start_idx == -1:
        return text.strip()

    end_idx = text.rfind("}")
    if end_idx == -1:
        cleaned = text[start_idx:]
    else:
        cleaned = text[start_idx : end_idx + 1]

    cleaned = re.sub(r"```json\s*", "", cleaned)
    cleaned = re.sub(r"```", "", cleaned)
    cleaned = cleaned.strip()

    # Structural repair
    open_b = cleaned.count("{") - cleaned.count("}")
    open_k = cleaned.count("[") - cleaned.count("]")
    if open_k > 0:
        cleaned += "]" * open_k
    if open_b > 0:
        cleaned += "}" * open_b

    return cleaned


# ---------------------------------------------------------------------------
# Core function for all 6-pillar analysis (used by company-rationale endpoint)
# ---------------------------------------------------------------------------

async def call_gemini_6pillar(
    query: str,
    system_instruction: str,
    is_async: bool = True,
) -> str:
    """
    Core function to call Gemini API for 6-pillar analysis.
    
    Args:
        query: The analysis request
        system_instruction: Custom system instruction for the specific use case
        is_async: Whether to run async (for generate_gemini_rationale) or sync (for run_reasoning_demo)
    
    Returns:
        Raw JSON response text from Gemini
    """
    api_key = os.getenv("GEMINI_API_KEY")
    if not api_key:
        raise RuntimeError("GEMINI_API_KEY is not set.")

    # Configure the API key
    genai.configure(api_key=api_key)

    # Create model with system instruction
    # Note: google_search_retrieval is NOT compatible with JSON response mode
    # Using gemini-3-flash-preview without search grounding
    model = genai.GenerativeModel(
        model_name="models/gemini-3-flash-preview",
        system_instruction=system_instruction,
        generation_config=genai.GenerationConfig(
            response_mime_type="application/json",
            max_output_tokens=6000,
            temperature=0.2,
        ),
    )

    if is_async:
        # Run sync generate_content in thread pool for async context
        response = await asyncio.to_thread(
            model.generate_content,
            query,
        )
    else:
        # Sync call (blocking)
        response = model.generate_content(query)

    return response.text



# ---------------------------------------------------------------------------
# Async reasoning for /api/ai/company-rationale
# ---------------------------------------------------------------------------

async def generate_gemini_rationale(
    investor_name: str,
    ticker: str,
    company_name: str,
    change_type: str,
    activity_summary: str,
) -> dict:
    """
    Async endpoint for single-company analysis.
    Analyzes why an investor changed a position and returns 6-pillar rationale.
    """
    query = (
        f"Analyze why {investor_name} {change_type} their position in "
        f"{ticker} ({company_name}).\n\n"
        f"Context from public filings:\n{activity_summary}"
    )

    # Call core Gemini function (async mode) using shared system instruction
    response_text = await call_gemini_6pillar(
        query=query,
        system_instruction=SYSTEM_INSTRUCTION,
        is_async=True
    )

    logger.info(f"Gemini rationale raw output for {ticker}: {response_text[:200]}...")

    cleaned = clean_json_text(response_text)
    result = json.loads(cleaned)

    # Normalize: if Gemini returned an array, take first item
    if isinstance(result, list):
        result = result[0] if result else {}

    return result


def to_company_rationale_response(
    gemini_result: dict,
    investor_name: str,
    company_name: str,
    ticker: str,
    activity_summary: str,
) -> dict:
    """
    Map Gemini 6-pillar output to AICompanyRationaleResponse shape.

    The returned dict is compatible with the Pydantic schema so the frontend
    card-back UI renders without changes.
    """
    # Build possible_rationales — one per pillar
    rationales = []
    for pillar in PILLAR_NAMES:
        text = gemini_result.get(pillar, "")
        if not text:
            continue
        # Extract any [E1], [E2] evidence markers
        evidence_ids = re.findall(r"\[E(\d+)\]", text)
        evidence_ids = [f"E{eid}" for eid in evidence_ids]

        rationales.append(
            {
                "hypothesis": f"[{PILLAR_LABELS.get(pillar, pillar)}] {text}",
                "supporting_signals": [f"Based on {PILLAR_LABELS.get(pillar, pillar)} analysis"],
                "evidence_ids": evidence_ids,
                "confidence": "medium" if pillar == "synthesis" else "low",
            }
        )

    # Build evidence signals from Gemini's evidence array + Google Search
    raw_evidence = gemini_result.get("evidence", [])
    signals_used = []
    for i, ev in enumerate(raw_evidence):
        eid = ev.get("id", f"E{i + 1}")
        signals_used.append(
            {
                "signal_id": eid,
                "category": "web_search",
                "description": ev.get("quote", "Google Search result"),
                "source": ev.get("url", "Google Search"),
                "value": ev.get("url", ""),
            }
        )

    # Add a disclosure metadata signal
    signals_used.insert(
        0,
        {
            "signal_id": "DISC_META_001",
            "category": "disclosure_metadata",
            "description": f"Analysis of {investor_name}'s disclosed activity in {ticker}",
            "source": "Public filings",
            "value": activity_summary[:200],
        },
    )

    evidence_panel = {
        "signals_used": signals_used,
        "unknowns": STANDARD_UNKNOWNS,
        "evidence_completeness": "sufficient" if len(signals_used) >= 3 else "limited",
        "should_auto_expand": False,
    }

    company_overview = gemini_result.get(
        "company_overview", f"{company_name} ({ticker})"
    )

    return {
        "company_overview": company_overview,
        "investor_activity_summary": activity_summary,
        "possible_rationales": rationales,
        "patterns_vs_history": gemini_result.get("synthesis", ""),
        "evidence_panel": evidence_panel,
        "what_is_unknown": (
            "We do not know the exact execution prices, the investor's private "
            "reasoning, or their future intentions."
        ),
        "disclaimer": DISCLAIMER,
    }


# ---------------------------------------------------------------------------
# Shared system instruction for consistency
# ---------------------------------------------------------------------------

SYSTEM_INSTRUCTION = (
    "You are an expert Institutional Investment Strategist. "
    "Return ONLY a valid JSON object with a 6-pillar analysis.\n\n"
    "REQUIRED JSON STRUCTURE:\n"
    "{\n"
    '  "company_overview": "Brief factual description of the company (1-2 sentences)",\n'
    '  "industry_competition": "Industry landscape and competitive positioning (max 80 words)",\n'
    '  "product_sales": "Product pipeline, revenue drivers, recent sales trends (max 80 words)",\n'
    '  "fundamentals": "Key financial metrics: P/E, revenue growth, margins (max 80 words)",\n'
    '  "reputation_papers": "Recent analyst coverage, research notes, market sentiment (max 80 words)",\n'
    '  "technical_analysis": "Recent price action, volume trends, key levels (max 80 words)",\n'
    '  "synthesis": "Overall hypothesis for why this investor may have taken this action (max 100 words)",\n'
    '  "evidence": [{"id": "E1", "url": "https://...", "quote": "short snippet"}]\n'
    "}\n\n"
    "CONSTRAINTS:\n"
    "1. Frame ALL analysis as HYPOTHETICAL — you do NOT know the investor's actual reasoning.\n"
    "2. NEVER recommend buying or selling. NEVER predict future prices.\n"
    "3. Use Google Search to ground claims with real data where possible.\n"
    "4. Evidence array should contain sources found via search.\n"
    "5. Keep the response factual and concise."
)

# ---------------------------------------------------------------------------
# Sync reasoning demo for /api/ai/reasoning-demo endpoint
# ---------------------------------------------------------------------------

def run_reasoning_demo(
    investor_name: str,
    ticker: str,
    company_name: str,
    change_type: str,
    activity_summary: str,
) -> dict:
    """
    Synchronous endpoint for 6-pillar reasoning demo.
    
    This function demonstrates Gemini's reasoning capabilities in a
    blocking manner (suitable for demo/testing). For production use,
    prefer the async version via /api/ai/company-rationale.
    
    COMPLIANCE:
    - Returns hypothetical analysis only
    - No investment advice or predictions
    - Includes mandatory disclaimers
    
    Args:
        investor_name: Name of the investor
        ticker: Stock ticker symbol
        company_name: Name of the company
        change_type: Type of change (e.g., "increased", "decreased")
        activity_summary: Summary of disclosed activity
    
    Returns:
        dict: AICompanyRationaleResponse-compatible response
    """
    query = (
        f"Analyze why {investor_name} {change_type} their position in "
        f"{ticker} ({company_name}).\n\n"
        f"Context from public filings:\n{activity_summary}"
    )

    # Use the shared call_gemini_6pillar function with sync mode
    import asyncio
    response_text = asyncio.run(
        call_gemini_6pillar(
            query=query,
            system_instruction=SYSTEM_INSTRUCTION,
            is_async=False  # Sync mode for blocking call
        )
    )

    logger.info(f"Gemini reasoning demo output for {ticker}: {response_text[:200]}...")

    cleaned = clean_json_text(response_text)
    result = json.loads(cleaned)

    # Normalize: if Gemini returned an array, take first item
    if isinstance(result, list):
        result = result[0] if result else {}

    # Map to response format
    return to_company_rationale_response(
        gemini_result=result,
        investor_name=investor_name,
        company_name=company_name,
        ticker=ticker,
        activity_summary=activity_summary,
    )
